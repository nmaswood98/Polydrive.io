

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      modules/SAT.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Collision Detection
    </h3>

    <h3>Classes</h3><ul><li id="Body-nav"><a href="Body.html">Body</a><ul class='methods'><li data-type="method" id="Body-createResult-nav"><a href="Body.html#.createResult">createResult</a></li><li data-type="method" id="Body-collides-nav"><a href="Body.html#collides">collides</a></li><li data-type="method" id="Body-createResult-nav"><a href="Body.html#createResult">createResult</a></li><li data-type="method" id="Body-potentials-nav"><a href="Body.html#potentials">potentials</a></li><li data-type="method" id="Body-remove-nav"><a href="Body.html#remove">remove</a></li></ul></li><li id="BVH-nav"><a href="BVH.html">BVH</a><ul class='methods'><li data-type="method" id="BVH-draw-nav"><a href="BVH.html#draw">draw</a></li><li data-type="method" id="BVH-drawBVH-nav"><a href="BVH.html#drawBVH">drawBVH</a></li><li data-type="method" id="BVH-insert-nav"><a href="BVH.html#insert">insert</a></li><li data-type="method" id="BVH-potentials-nav"><a href="BVH.html#potentials">potentials</a></li><li data-type="method" id="BVH-remove-nav"><a href="BVH.html#remove">remove</a></li><li data-type="method" id="BVH-update-nav"><a href="BVH.html#update">update</a></li></ul></li><li id="BVHBranch-nav"><a href="BVHBranch.html">BVHBranch</a><ul class='methods'><li data-type="method" id="BVHBranch-getBranch-nav"><a href="BVHBranch.html#.getBranch">getBranch</a></li><li data-type="method" id="BVHBranch-releaseBranch-nav"><a href="BVHBranch.html#.releaseBranch">releaseBranch</a></li><li data-type="method" id="BVHBranch-sortBranches-nav"><a href="BVHBranch.html#.sortBranches">sortBranches</a></li></ul></li><li id="Circle-nav"><a href="Circle.html">Circle</a><ul class='methods'><li data-type="method" id="Circle-draw-nav"><a href="Circle.html#draw">draw</a></li></ul></li><li id="Collisions-nav"><a href="Collisions.html">Collisions</a><ul class='methods'><li data-type="method" id="Collisions-createResult-nav"><a href="Collisions.html#.createResult">createResult</a></li><li data-type="method" id="Collisions-collides-nav"><a href="Collisions.html#collides">collides</a></li><li data-type="method" id="Collisions-createCircle-nav"><a href="Collisions.html#createCircle">createCircle</a></li><li data-type="method" id="Collisions-createPoint-nav"><a href="Collisions.html#createPoint">createPoint</a></li><li data-type="method" id="Collisions-createPolygon-nav"><a href="Collisions.html#createPolygon">createPolygon</a></li><li data-type="method" id="Collisions-createResult-nav"><a href="Collisions.html#createResult">createResult</a></li><li data-type="method" id="Collisions-draw-nav"><a href="Collisions.html#draw">draw</a></li><li data-type="method" id="Collisions-drawBVH-nav"><a href="Collisions.html#drawBVH">drawBVH</a></li><li data-type="method" id="Collisions-insert-nav"><a href="Collisions.html#insert">insert</a></li><li data-type="method" id="Collisions-potentials-nav"><a href="Collisions.html#potentials">potentials</a></li><li data-type="method" id="Collisions-remove-nav"><a href="Collisions.html#remove">remove</a></li><li data-type="method" id="Collisions-update-nav"><a href="Collisions.html#update">update</a></li></ul></li><li id="Point-nav"><a href="Point.html">Point</a></li><li id="Polygon-nav"><a href="Polygon.html">Polygon</a><ul class='methods'><li data-type="method" id="Polygon-_calculateCoords-nav"><a href="Polygon.html#_calculateCoords">_calculateCoords</a></li><li data-type="method" id="Polygon-_calculateNormals-nav"><a href="Polygon.html#_calculateNormals">_calculateNormals</a></li><li data-type="method" id="Polygon-draw-nav"><a href="Polygon.html#draw">draw</a></li><li data-type="method" id="Polygon-setPoints-nav"><a href="Polygon.html#setPoints">setPoints</a></li></ul></li><li id="Result-nav"><a href="Result.html">Result</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#aabbAABB">aabbAABB</a></li><li><a href="global.html#branch_pool">branch_pool</a></li><li><a href="global.html#circleCircle">circleCircle</a></li><li><a href="global.html#polygonCircle">polygonCircle</a></li><li><a href="global.html#polygonPolygon">polygonPolygon</a></li><li><a href="global.html#SAT">SAT</a></li><li><a href="global.html#separatingAxis">separatingAxis</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        modules/SAT.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/**
 * Determines if two bodies are colliding using the Separating Axis Theorem
 * @private
 * @param {Circle|Polygon|Point} a The source body to test
 * @param {Circle|Polygon|Point} b The target body to test against
 * @param {Result} [result = null] A Result object on which to store information about the collision
 * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own collision heuristic)
 * @returns {Boolean}
 */
function SAT (a, b, result = null, aabb = true) {
  const a_polygon = a._polygon
  const b_polygon = b._polygon

  let collision = false

  if (result) {
    result.a = a
    result.b = b
    result.a_in_b = true
    result.b_in_a = true
    result.overlap = null
    result.overlap_x = 0
    result.overlap_y = 0
  }

  if (a_polygon) {
    if (
      a._dirty_coords ||
      a.x !== a._x ||
      a.y !== a._y ||
      a.angle !== a._angle ||
      a.scale_x !== a._scale_x ||
      a.scale_y !== a._scale_y
    ) {
      a._calculateCoords()
    }
  }

  if (b_polygon) {
    if (
      b._dirty_coords ||
      b.x !== b._x ||
      b.y !== b._y ||
      b.angle !== b._angle ||
      b.scale_x !== b._scale_x ||
      b.scale_y !== b._scale_y
    ) {
      b._calculateCoords()
    }
  }

  if (!aabb || aabbAABB(a, b)) {
    if (a_polygon &amp;&amp; a._dirty_normals) {
      a._calculateNormals()
    }

    if (b_polygon &amp;&amp; b._dirty_normals) {
      b._calculateNormals()
    }

    collision = (
      a_polygon &amp;&amp; b_polygon ? polygonPolygon(a, b, result)
        : a_polygon ? polygonCircle(a, b, result, false)
          : b_polygon ? polygonCircle(b, a, result, true)
            : circleCircle(a, b, result)
    )
  }

  if (result) {
    result.collision = collision
  }

  return collision
};

/**
 * Determines if two bodies' axis aligned bounding boxes are colliding
 * @param {Circle|Polygon|Point} a The source body to test
 * @param {Circle|Polygon|Point} b The target body to test against
 */
function aabbAABB (a, b) {
  const a_polygon = a._polygon
  const a_x = a_polygon ? 0 : a.x
  const a_y = a_polygon ? 0 : a.y
  const a_radius = a_polygon ? 0 : a.radius * a.scale
  const a_min_x = a_polygon ? a._min_x : a_x - a_radius
  const a_min_y = a_polygon ? a._min_y : a_y - a_radius
  const a_max_x = a_polygon ? a._max_x : a_x + a_radius
  const a_max_y = a_polygon ? a._max_y : a_y + a_radius

  const b_polygon = b._polygon
  const b_x = b_polygon ? 0 : b.x
  const b_y = b_polygon ? 0 : b.y
  const b_radius = b_polygon ? 0 : b.radius * b.scale
  const b_min_x = b_polygon ? b._min_x : b_x - b_radius
  const b_min_y = b_polygon ? b._min_y : b_y - b_radius
  const b_max_x = b_polygon ? b._max_x : b_x + b_radius
  const b_max_y = b_polygon ? b._max_y : b_y + b_radius

  return a_min_x &lt; b_max_x &amp;&amp; a_min_y &lt; b_max_y &amp;&amp; a_max_x > b_min_x &amp;&amp; a_max_y > b_min_y
}

/**
 * Determines if two polygons are colliding
 * @param {Polygon} a The source polygon to test
 * @param {Polygon} b The target polygon to test against
 * @param {Result} [result = null] A Result object on which to store information about the collision
 * @returns {Boolean}
 */
function polygonPolygon (a, b, result = null) {
  const a_count = a._coords.length
  const b_count = b._coords.length

  // Handle points specially
  if (a_count === 2 &amp;&amp; b_count === 2) {
    const a_coords = a._coords
    const b_coords = b._coords

    if (result) {
      result.overlap = 0
    }

    return a_coords[0] === b_coords[0] &amp;&amp; a_coords[1] === b_coords[1]
  }

  const a_coords = a._coords
  const b_coords = b._coords
  const a_normals = a._normals
  const b_normals = b._normals

  if (a_count > 2) {
    for (let ix = 0, iy = 1; ix &lt; a_count; ix += 2, iy += 2) {
      if (separatingAxis(a_coords, b_coords, a_normals[ix], a_normals[iy], result)) {
        return false
      }
    }
  }

  if (b_count > 2) {
    for (let ix = 0, iy = 1; ix &lt; b_count; ix += 2, iy += 2) {
      if (separatingAxis(a_coords, b_coords, b_normals[ix], b_normals[iy], result)) {
        return false
      }
    }
  }

  return true
}

/**
 * Determines if a polygon and a circle are colliding
 * @param {Polygon} a The source polygon to test
 * @param {Circle} b The target circle to test against
 * @param {Result} [result = null] A Result object on which to store information about the collision
 * @param {Boolean} [reverse = false] Set to true to reverse a and b in the result parameter when testing circle->polygon instead of polygon->circle
 * @returns {Boolean}
 */
function polygonCircle (a, b, result = null, reverse = false) {
  const a_coords = a._coords
  const a_edges = a._edges
  const a_normals = a._normals
  const b_x = b.x
  const b_y = b.y
  const b_radius = b.radius * b.scale
  const b_radius2 = b_radius * 2
  const radius_squared = b_radius * b_radius
  const count = a_coords.length

  let a_in_b = true
  let b_in_a = true
  let overlap = null
  let overlap_x = 0
  let overlap_y = 0

  // Handle points specially
  if (count === 2) {
    const coord_x = b_x - a_coords[0]
    const coord_y = b_y - a_coords[1]
    const length_squared = coord_x * coord_x + coord_y * coord_y

    if (length_squared > radius_squared) {
      return false
    }

    if (result) {
      const length = Math.sqrt(length_squared)

      overlap = b_radius - length
      overlap_x = coord_x / length
      overlap_y = coord_y / length
      b_in_a = false
    }
  } else {
    for (let ix = 0, iy = 1; ix &lt; count; ix += 2, iy += 2) {
      const coord_x = b_x - a_coords[ix]
      const coord_y = b_y - a_coords[iy]
      const edge_x = a_edges[ix]
      const edge_y = a_edges[iy]
      const dot = coord_x * edge_x + coord_y * edge_y
      const region = dot &lt; 0 ? -1 : dot > edge_x * edge_x + edge_y * edge_y ? 1 : 0

      let tmp_overlapping = false
      let tmp_overlap = 0
      let tmp_overlap_x = 0
      let tmp_overlap_y = 0

      if (result &amp;&amp; a_in_b &amp;&amp; coord_x * coord_x + coord_y * coord_y > radius_squared) {
        a_in_b = false
      }

      if (region) {
        const left = region === -1
        const other_x = left ? (ix === 0 ? count - 2 : ix - 2) : (ix === count - 2 ? 0 : ix + 2)
        const other_y = other_x + 1
        const coord2_x = b_x - a_coords[other_x]
        const coord2_y = b_y - a_coords[other_y]
        const edge2_x = a_edges[other_x]
        const edge2_y = a_edges[other_y]
        const dot2 = coord2_x * edge2_x + coord2_y * edge2_y
        const region2 = dot2 &lt; 0 ? -1 : dot2 > edge2_x * edge2_x + edge2_y * edge2_y ? 1 : 0

        if (region2 === -region) {
          const target_x = left ? coord_x : coord2_x
          const target_y = left ? coord_y : coord2_y
          const length_squared = target_x * target_x + target_y * target_y

          if (length_squared > radius_squared) {
            return false
          }

          if (result) {
            const length = Math.sqrt(length_squared)

            tmp_overlapping = true
            tmp_overlap = b_radius - length
            tmp_overlap_x = target_x / length
            tmp_overlap_y = target_y / length
            b_in_a = false
          }
        }
      } else {
        const normal_x = a_normals[ix]
        const normal_y = a_normals[iy]
        const length = coord_x * normal_x + coord_y * normal_y
        const absolute_length = length &lt; 0 ? -length : length

        if (length > 0 &amp;&amp; absolute_length > b_radius) {
          return false
        }

        if (result) {
          tmp_overlapping = true
          tmp_overlap = b_radius - length
          tmp_overlap_x = normal_x
          tmp_overlap_y = normal_y

          if (b_in_a &amp;&amp; (length >= 0) || (tmp_overlap &lt; b_radius2)) {
            b_in_a = false
          }
        }
      }

      if (tmp_overlapping &amp;&amp; (overlap === null || overlap > tmp_overlap)) {
        overlap = tmp_overlap
        overlap_x = tmp_overlap_x
        overlap_y = tmp_overlap_y
      }
    }
  }

  if (result) {
    result.a_in_b = reverse ? b_in_a : a_in_b
    result.b_in_a = reverse ? a_in_b : b_in_a
    result.overlap = overlap
    result.overlap_x = reverse ? -overlap_x : overlap_x
    result.overlap_y = reverse ? -overlap_y : overlap_y
  }

  return true
}

/**
 * Determines if two circles are colliding
 * @param {Circle} a The source circle to test
 * @param {Circle} b The target circle to test against
 * @param {Result} [result = null] A Result object on which to store information about the collision
 * @returns {Boolean}
 */
function circleCircle (a, b, result = null) {
  const a_radius = a.radius * a.scale
  const b_radius = b.radius * b.scale
  const difference_x = b.x - a.x
  const difference_y = b.y - a.y
  const radius_sum = a_radius + b_radius
  const length_squared = difference_x * difference_x + difference_y * difference_y

  if (length_squared > radius_sum * radius_sum) {
    return false
  }

  if (result) {
    const length = Math.sqrt(length_squared)

    result.a_in_b = a_radius &lt;= b_radius &amp;&amp; length &lt;= b_radius - a_radius
    result.b_in_a = b_radius &lt;= a_radius &amp;&amp; length &lt;= a_radius - b_radius
    result.overlap = radius_sum - length
    result.overlap_x = difference_x / length
    result.overlap_y = difference_y / length
  }

  return true
}

/**
 * Determines if two polygons are separated by an axis
 * @param {Array&lt;Number[]>} a_coords The coordinates of the polygon to test
 * @param {Array&lt;Number[]>} b_coords The coordinates of the polygon to test against
 * @param {Number} x The X direction of the axis
 * @param {Number} y The Y direction of the axis
 * @param {Result} [result = null] A Result object on which to store information about the collision
 * @returns {Boolean}
 */
function separatingAxis (a_coords, b_coords, x, y, result = null) {
  const a_count = a_coords.length
  const b_count = b_coords.length

  if (!a_count || !b_count) {
    return true
  }

  let a_start = null
  let a_end = null
  let b_start = null
  let b_end = null

  for (let ix = 0, iy = 1; ix &lt; a_count; ix += 2, iy += 2) {
    const dot = a_coords[ix] * x + a_coords[iy] * y

    if (a_start === null || a_start > dot) {
      a_start = dot
    }

    if (a_end === null || a_end &lt; dot) {
      a_end = dot
    }
  }

  for (let ix = 0, iy = 1; ix &lt; b_count; ix += 2, iy += 2) {
    const dot = b_coords[ix] * x + b_coords[iy] * y

    if (b_start === null || b_start > dot) {
      b_start = dot
    }

    if (b_end === null || b_end &lt; dot) {
      b_end = dot
    }
  }

  if (a_start > b_end || a_end &lt; b_start) {
    return true
  }

  if (result) {
    let overlap = 0

    if (a_start &lt; b_start) {
      result.a_in_b = false

      if (a_end &lt; b_end) {
        overlap = a_end - b_start
        result.b_in_a = false
      } else {
        const option1 = a_end - b_start
        const option2 = b_end - a_start

        overlap = option1 &lt; option2 ? option1 : -option2
      }
    } else {
      result.b_in_a = false

      if (a_end > b_end) {
        overlap = a_start - b_end
        result.a_in_b = false
      } else {
        const option1 = a_end - b_start
        const option2 = b_end - a_start

        overlap = option1 &lt; option2 ? option1 : -option2
      }
    }

    const current_overlap = result.overlap
    const absolute_overlap = overlap &lt; 0 ? -overlap : overlap

    if (current_overlap === null || current_overlap > absolute_overlap) {
      const sign = overlap &lt; 0 ? -1 : 1

      result.overlap = absolute_overlap
      result.overlap_x = x * sign
      result.overlap_y = y * sign
    }
  }

  return false
}

module.exports = SAT

module.exports.default = module.exports
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  
  
</body>
</html>
